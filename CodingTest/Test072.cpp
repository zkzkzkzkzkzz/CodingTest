

// 비트 연산자
// & : 두 비트가 모두 1이면 1을 반환 (비트 AND 연산)
// | : 두 비트 중 하나라도 1이면 1을 반환 (비트 OR 연산)
// ^ : 두 비트가 다르면 1을 반환 (비트 XOR 연산)
// ~ : 비트가 1이면 0으로, 0이면 1로 반전 (비트 NOT 연산)
// << : 지정한 수만큼 비트들을 전부 왼쪽으로 이동 (left shift 연산)
// >> : 부호를 유지하면서 지정한 수만큼 비트를 전부 오른쪽으로 이동시킴 (right shift 연산)


class Solution {
public:
    int getSum(int a, int b)
    {
        //    (2, 3)     (7, 10)
        //  0000 0010   0000 0111
        //  0000 0011   0000 1010
        //  ---------   ---------
        //  0000 0101   0001 0001

        // a & b -> 1이면 '<< 1'

        //& 0000 0010   0000 0010
        //^ 0000 0001   0000 1101
        //<<0000 0100   0000 0100

        //& 0000 0000   0000 0100
        //^ 0000 0101   0000 1001
        //<<            0000 1000

        //&             0000 1000
        //^             0000 0001
        //<<            0001 0000

        //&             0000 0000
        //^             0001 0001
        //<<

        // AND 연산에서 1은 올림을 의미하고
        // XOR 연산은 올림을 고려하지 않은 두 비트의 합을 의미한다
        // 그렇기 때문에 AND 연산의 결과가 0이 아닐 때까지 while문을 돌린다
        int Res = 0;
        int And = a & b;
        int Xor = a ^ b;

        while (And != 0)
        {
            int temp = And << 1;

            And = temp & Xor;
            Xor = temp ^ Xor;
        }

        Res = Xor;

        return Res;
    }
};


int main()
{
    Solution sol;

    sol.getSum(2, 3);

    return 0;
}